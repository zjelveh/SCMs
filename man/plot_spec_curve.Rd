% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_spec_curve.R
\name{plot_spec_curve}
\alias{plot_spec_curve}
\title{Plot Specification Curve with Internal SHAP Computation and Filtering}
\usage{
plot_spec_curve(
  long_data,
  name_treated_unit,
  outcomes = NULL,
  normalize_outcomes = "none",
  rmse_threshold = Inf,
  shap_values = NULL,
  file_path_save = NA,
  width = 6,
  height = 10,
  show_pvalues = FALSE,
  p_threshold = 0.05,
  prefer_bootstrap_pvalues = FALSE,
  test_statistic = "rmse_ratio",
  null_distribution = "placebo",
  crop_outliers = "none",
  sort_by = "tau",
  filter_specs = NULL,
  show_shap = TRUE,
  shap_config = list(compute_pvalues = TRUE, pvalue_type = "absolute"),
  shap_label_type = "absolute",
  show_predictions = FALSE,
  predictions = NULL,
  xgboost_params = NULL,
  tune_xgboost = NULL,
  xgboost_grid = NULL,
  xgboost_cv_folds = 5
)
}
\arguments{
\item{long_data}{Data.table or List. Long format data from spec_curve().
Can be either the results data.table directly, or the full structured results
(with results, abadie_inference, bootstrap_inference components).}

\item{name_treated_unit}{Character. Name of the treated unit.}

\item{outcomes}{Character vector or NULL. Names of the outcome variables to plot. If NULL, all outcomes in the data will be plotted.}

\item{normalize_outcomes}{Character. Method for normalizing treatment effects for comparability.
Options: "none" (default), "percent_of_mean", "percent_of_preperiod", "standardized", "rmspe_ratio".
\itemize{
\item "percent_of_mean": (tau / mean(pre-period treated)) * 100
\item "percent_of_preperiod": (tau / final_preperiod_value) * 100
\item "standardized": tau / sd(control_effects)
\item "rmspe_ratio": post_RMSPE / pre_RMSPE (Abadie-style)
}}

\item{rmse_threshold}{Numeric. Threshold for root mean square error to filter results. Default is Inf.}

\item{shap_values}{Data.table or NULL. External SHAP values from run_xgboost_shap_analysis().
Should contain columns: unit, full_spec_id, feature_group, feature, shapley_value.
If NULL and show_shap=TRUE, SHAP values will be computed internally. Default is NULL.}

\item{file_path_save}{Character or NA. File path to save the plot. If NA, plot is not saved. Default is NA.}

\item{width}{Numeric. Width of the saved plot in inches. Default is 6.}

\item{height}{Numeric. Height of the saved plot in inches. Default is 10.}

\item{show_pvalues}{Logical. Whether to include significance coloring for treatment effects.
Uses Abadie p-values by default, or bootstrap p-values if available. Default is TRUE.}

\item{p_threshold}{Numeric. P-value threshold for significance coloring. Default is 0.05.}

\item{prefer_bootstrap_pvalues}{Logical. Whether to prefer bootstrap p-values over Abadie p-values
when both are available. Default is FALSE (prefer Abadie).}

\item{test_statistic}{Character. Which test statistic p-values to use for coloring.
Options: "rmse_ratio" (default), "treatment_effect", "normalized_te".
Only applies to Abadie placebo inference which provides multiple test statistics.}

\item{null_distribution}{Character. The distribution to plot as the null/comparison.
Options: "placebo" (default) or "bootstrap".
\itemize{
\item "placebo": Use placebo effects from control units as the null distribution.
\item "bootstrap": Use the bootstrapped null distribution for the treated unit.
}}

\item{crop_outliers}{Character or Numeric. Method for cropping outliers in Panel A.
Options: "none" (default), "percentile", "iqr", "mad", or numeric vector c(ymin, ymax).
\itemize{
\item "percentile": Crop to 1st-99th percentile of treated unit effects
\item "iqr": Crop to Q1 - 1.5\emph{IQR to Q3 + 1.5}IQR
\item "mad": Crop to median +/- 3*MAD (robust outlier detection)
\item c(ymin, ymax): Manual y-axis limits
}}

\item{sort_by}{Character. Method for sorting specifications on x-axis.
Options: "tau" (default), "pvalue", "rmspe_ratio".
\itemize{
\item "tau": Sort by treatment effect magnitude (original behavior)
\item "pvalue": Sort by statistical significance (most significant first)
\item "rmspe_ratio": Sort by post/pre RMSPE ratio
}}

\item{filter_specs}{Named list or NULL. Filters to apply to specifications BEFORE SHAP computation and p-value calculation.
Each element should be named by the feature group column and contain allowed values.
Available filters: "constant" (TRUE/FALSE), "const" (simplex/lasso/ridge/pensynth),
"outcome_model" (none/augsynth/lasso/ridge/ols), "fw" (uniform/optimize),
"feat" (covariate aggregation labels), "data_sample" (all/most_similar).
Examples: list(constant = "TRUE"), list(const = c("simplex", "lasso")),
list(constant = "TRUE", outcome_model = c("none", "augsynth")). Default is NULL (no filtering).}

\item{show_shap}{Logical. Whether to compute and display SHAP values. When TRUE:
\itemize{
\item If shap_values is provided: uses external SHAP values
\item If shap_values is NULL: computes SHAP values internally using XGBoost
\item Requires at least 3 unique specifications for internal computation
\item Automatically detects available specification features (outcome_model, const, fw, feat, data_sample, constant)
Default is TRUE.
}}

\item{shap_config}{List. Configuration for SHAP computation and significance testing with elements:
\itemize{
\item compute_pvalues: Logical. Whether to calculate SHAP significance via placebo inference.
Requires multi-unit SHAP data (treated_unit_only = FALSE in XGBoost config). Default is TRUE.
\item pvalue_type: Character. Method for SHAP significance testing: "absolute" or "signed".
"absolute" ranks by |SHAP| values, "signed" uses two-sided rank-based test. Default is "absolute".
}}

\item{shap_label_type}{Character. How to display SHAP values in y-axis labels: "absolute" or "signed".
\itemize{
\item "absolute": Shows mean |SHAP| values, e.g., "ridge (0.123)"
\item "signed": Shows mean SHAP values with sign, e.g., "ridge (+0.089)" or "lasso (-0.045)"
Default is "absolute".
}}

\item{show_predictions}{Logical. Whether to display predicted treatment effects from XGBoost models
alongside actual treatment effects in Panel A. Uses leave-one-out cross-validation predictions
for robust evaluation. Default is FALSE.}

\item{predictions}{Data.table or NULL. External LOO predictions from run_xgboost_shap_analysis().
Should contain columns: unit, full_spec_id, predicted_loo, actual.
If NULL and show_predictions=TRUE, predictions will be computed internally. Default is NULL.}

\item{xgboost_params}{List. Custom parameters for XGBoost model training. If NULL, uses defaults:
list(objective='reg:squarederror', max_depth=10, eta=0.05, nrounds=500, subsample=0.8,
colsample_bytree=0.8, nthread=1, seed=42, verbose=0). Common parameters to modify:
nrounds (more = better fit but slower), max_depth (complexity), eta (learning rate).
Default is NULL. If tune_xgboost is TRUE, xgboost_params must be NULL.}

\item{tune_xgboost}{Logical or NULL. If TRUE, tune XGBoost hyperparameters via
k-fold CV on the treated unit before SHAP/LOO. If NULL, defaults to TRUE when
xgboost_params is NULL and FALSE otherwise. Default is NULL.}

\item{xgboost_grid}{Data.frame, data.table, or list. Optional grid for tuning.
Must include max_depth, eta, nrounds, subsample, colsample_bytree. Default is NULL.}

\item{xgboost_cv_folds}{Integer. Number of CV folds for tuning. Default is 5.}
}
\value{
List containing:
\itemize{
\item final_plot: ggplot object representing the complete specification curve with Panel A (treatment effects) and Panel B (feature groups/SHAP)
\item panel_a: ggplot object for Panel A only (treatment effects)
\item panel_b: ggplot object for Panel B only (feature groups/SHAP)
\item plot_data_p1: data.table with Panel A plotting data including columns: Unit Name, Estimate, RMSE, Specification, unit_type, p_value (if available)
\item plot_data_p2: data.table with Panel B plotting data including columns: Specification, feature_group, feature, shapley_value (if SHAP computed), shap_pvalue (if significance computed)
\item computed_shap: Complete results from internal SHAP computation (NULL if external shap_values provided or show_shap=FALSE).
Contains: results (feature importance), shapley (SHAP values), predictions (model predictions), models (trained XGBoost models), config (SHAP configuration)
\item spec_curve_pvals: List with specification curve-level p-values calculated on filtered data:
median_tau_pvalues (median treatment effect ranks), stouffer_pvalues (Stouffer's Z-method ranks). NULL if no inference data available
\item filtered_specs: Integer count of specifications remaining after filtering (before filtering if filter_specs=NULL)
\item feature_groups_displayed: Character vector of feature groups shown in Panel B (only groups with variation in filtered data)
}
}
\description{
Creates specification curve plots directly from long format data with integrated
SHAP analysis and flexible filtering capabilities. Key features:
\itemize{
\item Internal SHAP computation using XGBoost (automatic when show_shap=TRUE)
\item Specification filtering BEFORE SHAP computation and p-value calculation
\item Perfect alignment between SHAP values and specifications via full_spec_id
\item FAIL HARD error handling with specific guidance when requirements aren't met
}
}
\details{
Plot Specification Curve Using Direct Long Format Data
}
\examples{
\dontrun{
# ===== RECOMMENDED WORKFLOW: Internal SHAP Computation =====

# 1. Generate specification curve data
spec_results <- run_spec_curve_analysis(
  dataset = your_data,
  params = your_params,
  inference_type = "placebo"
)

# 2. Basic plot with internal SHAP computation (most common use case)
plot_basic <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  show_shap = TRUE,  # Automatically computes SHAP internally
  shap_config = list(
    compute_pvalues = TRUE,
    pvalue_type = "absolute"
  )
)

# ===== SPECIFICATION FILTERING EXAMPLES =====

# Filter by constant terms only
plot_constant_only <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  filter_specs = list(constant = "TRUE"),
  show_shap = TRUE
)

# Filter by multiple criteria (AND logic)
plot_filtered <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  filter_specs = list(
    constant = "TRUE",
    const = c("simplex", "lasso"),
    outcome_model = c("none", "augsynth")
  ),
  show_shap = TRUE
)

# Compare specific constraint methods
plot_constraints <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  filter_specs = list(const = c("simplex", "lasso", "ridge")),
  show_shap = TRUE,
  shap_config = list(compute_pvalues = FALSE)  # Disable SHAP significance
)

# ===== DIFFERENT TEST STATISTICS =====

# Using treatment effect p-values
plot_treatment_effect <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  test_statistic = "treatment_effect",
  show_shap = TRUE
)

# Using RMSE ratio p-values (default)
plot_rmse_ratio <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  test_statistic = "rmse_ratio",
  show_shap = TRUE
)

# ===== SHAP SIGNIFICANCE TESTING =====

# SHAP with signed significance testing
plot_shap_signed <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  show_shap = TRUE,
  shap_config = list(
    compute_pvalues = TRUE,
    pvalue_type = "signed"  # Two-sided SHAP significance
  )
)

# ===== EXTERNAL SHAP WORKFLOW (Advanced) =====

# For advanced users who want external control over SHAP computation
shap_config_external <- create_xgboost_config(
  dataset_name = "example",
  treated_unit_name = "TREATED_ID",
  treated_unit_only = FALSE  # Multi-unit for significance testing
)
external_shap <- run_xgboost_shap_analysis(spec_results, shap_config_external)

plot_external_shap <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  shap_values = external_shap$shapley,  # Provide external SHAP
  show_shap = TRUE
)

# ===== OTHER OPTIONS =====

# Disable SHAP entirely
plot_no_shap <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  show_shap = FALSE
)

# Crop outliers and sort by p-values
plot_customized <- plot_spec_curve(
  long_data = spec_results,
  name_treated_unit = "TREATED_ID",
  show_shap = TRUE,
  crop_outliers = "percentile",
  sort_by = "pvalue",
  normalize_outcomes = "standardized"
)

# ===== EXTRACTING INDIVIDUAL PANELS =====

# Extract and display only Panel A (treatment effects)

# Extract and save Panel B (specification features/SHAP)

}
}
